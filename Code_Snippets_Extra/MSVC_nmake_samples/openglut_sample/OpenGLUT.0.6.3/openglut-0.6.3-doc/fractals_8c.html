<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="KeyWords" content="OpenGLUT, FreeGLUT, OpenGL, GLUT, X11, Windows, Programming, Documentation, Download, Development, Sourceforge">
<title>OpenGLUT 0.6.3 development - OpenGLUT: fractals.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<div class="qindex">
<center><b>OpenGLUT Documentation</b></center>
<a class="qindex" style="font-size: 80%" href="index.html">Introduction</a>         | 
<a class="qindex" style="font-size: 80%" href="group__api.html">Documentation</a>   | 
<a class="qindex" style="font-size: 80%" href="group__examples.html">Examples</a>   |  
<a class="qindex" style="font-size: 80%" href="group__proposals.html">Proposals</a> |
<a class="qindex" style="font-size: 80%" href="authors.html">Authors</a>            | 
<a class="qindex" style="font-size: 80%" href="copying.html">Copying</a>            | 
<a class="qindex" style="font-size: 80%" href="todo.html">Todo</a>                  | 
<a class="qindex" style="font-size: 80%" href="bug.html">Bugs</a>                   | 
<a class="qindex" style="font-size: 80%" href="otherdoc.html">Links</a> 
</div>
<!-- Generated by Doxygen 1.3.8 -->
<h1>fractals.c File Reference</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Program to draw a fractal by Michael Barnsley's deterministic algorithm.<p>
Algorithm:<p>
<ul>
<li>Define the affine transformations (of the form <img class="formulaInl" alt="$r_{i+1} = A r_i + b $" src="form_0.png">)</li><li>Find the stationary point for each transformation</li><li>To draw:<ul>
<li>If you are at the lowest level, draw lines connecting all the stationary points</li><li>If not, call the draw function recursively with each affine transformation applied</li></ul>
</li></ul>
<p>
User Interaction:<p>
<ul>
<li>+,- : increment/decrement number of levels</li><li>PgUp, PgDn : increase/decrease scaling</li><li>Arrow keys : translate viewing section</li><li>r : reset view</li><li>Escape : quit</li></ul>
<p>
<dl compact><dt><b>Author:</b></dt><dd>Portions Copyright (C) 2004, the OpenGLUT project contributors. <br>
 OpenGLUT branched from freeglut in February, 2004.</dd></dl>
<div align="center">
<img src="openglut_fractals.png" alt="openglut_fractals.png">
<p><strong>OpenGLUT Fractal Demonstration</strong></p></div>
 <div class="fragment"><pre>
<span class="preprocessor">#include &lt;GL/openglut.h&gt;</span>

<span class="preprocessor">#include &lt;math.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="keyword">typedef</span> <span class="keyword">struct</span>
<span class="keyword"></span>{
    <span class="keywordtype">double</span> a00, a01, a10, a11;    <span class="comment">/* Transformation matrix */</span>
    <span class="keywordtype">double</span> b0, b1;                <span class="comment">/* Constant vector added on */</span>
    <span class="keywordtype">double</span> statx, staty;          <span class="comment">/* Coordinates of the stationary point */</span>
}
AffineTrans;

<span class="comment">/* Number of levels to draw the fractal */</span>
<span class="keyword">static</span> <span class="keywordtype">int</span> num_levels = 0;

<span class="comment">/* The definition of the fractal */</span>
<span class="keyword">static</span> <span class="keywordtype">int</span> num_trans;
<span class="keyword">static</span> AffineTrans *affine;

<span class="comment">/* the window title */</span>
<span class="preprocessor">#define WIN_TITLE_LENGTH 80</span>
<span class="preprocessor"></span><span class="keywordtype">char</span> window_title[ WIN_TITLE_LENGTH + 1 ];

<span class="comment">/* The amount the view is translated and scaled */</span>
<span class="keywordtype">double</span> xwin = 0.0, ywin = 0.0;
<span class="keywordtype">double</span> scale_factor = 1.0;

<span class="keyword">static</span> <span class="keywordtype">void</span> draw_level(
    <span class="keywordtype">int</span> num,
    <span class="keywordtype">double</span> m00, <span class="keywordtype">double</span> m01, <span class="keywordtype">double</span> m10, <span class="keywordtype">double</span> m11, <span class="keywordtype">double</span> n0, <span class="keywordtype">double</span> n1
)
{
    <span class="comment">/* Draw a fractal transformed by "M", "N" as passed in */</span>
    <span class="keywordtype">int</span> i;

    <span class="keywordflow">if</span>( !num )
    {
        <span class="keywordtype">double</span> x0 = m00 * affine[0].statx + m01 * affine[0].staty + n0;
        <span class="keywordtype">double</span> y0 = m10 * affine[0].statx + m11 * affine[0].staty + n1;

        <span class="keywordflow">for</span>( i = 1; i &lt; num_trans; i++ )
        {
            <span class="keywordtype">double</span> x1 = m00 * affine[i].statx + m01 * affine[i].staty + n0;
            <span class="keywordtype">double</span> y1 = m10 * affine[i].statx + m11 * affine[i].staty + n1;

            glVertex2d ( x0, y0 );
            glVertex2d ( x1, y1 );

            x0 = x1;
            y0 = y1;
        }
    }
    <span class="keywordflow">else</span>
        <span class="comment">/*</span>
<span class="comment">         * Map each affine transformation in the fractal through</span>
<span class="comment">         * the one passed in and call draw_level()</span>
<span class="comment">         */</span>
        <span class="keywordflow">for</span>( i = 0; i &lt; num_trans; i++ )
            draw_level(
                num-1,
                m00*affine[i].a00+m01*affine[i].a10,
                m00*affine[i].a01+m01*affine[i].a11,
                m10*affine[i].a00+m11*affine[i].a10,
                m10*affine[i].a01+m11*affine[i].a11,
                m00*affine[i].b0 +m01*affine[i].b1 + n0,
                m10*affine[i].b0 +m11*affine[i].b1 + n1
            );
}

<span class="keyword">static</span> <span class="keywordtype">void</span> Display( <span class="keywordtype">void</span> )
{
    glClear( GL_COLOR_BUFFER_BIT );

    <span class="comment">/* the curve */</span>
    glPushMatrix();
    glScalef(2.5, 2.5, 2.5);

    glColor4f(0.0, 0.0, 0.0, 1.0);
    glBegin( GL_LINES );
    draw_level( num_levels, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 );
    glEnd( );

    glPopMatrix();
    <a class="code" href="group__window.html#ga3">glutSwapBuffers</a>();
}

<span class="keyword">static</span> <span class="keywordtype">void</span> Reshape( <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height )
{
    <span class="keywordtype">float</span> ar;
    glViewport( 0, 0, width, height );
    glMatrixMode( GL_PROJECTION );
    glLoadIdentity( );
    ar = ( <span class="keywordtype">float</span> )width / ( <span class="keywordtype">float</span> )height;
    <span class="keywordflow">if</span>( ar &gt; 1 )
        glFrustum( -ar, ar, -1.0, 1.0, 2.0, 100.0 );
    <span class="keywordflow">else</span>
        glFrustum( -1.0, 1.0, -1/ar, 1/ar, 2.0, 100.0 );
    glMatrixMode( GL_MODELVIEW );
    glLoadIdentity( );
    xwin = -1.0;
    ywin =  0.0;
    glTranslated( xwin, ywin, -5.0 );
}

<span class="keyword">static</span> <span class="keywordtype">void</span> Key( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )
{
    <span class="keywordtype">int</span> need_redisplay = 1;
  
    <span class="keywordflow">switch</span> (key) {
    <span class="keywordflow">case</span> 27:  <span class="comment">/* Escape key */</span>
        <a class="code" href="group__mainloop.html#ga3">glutLeaveMainLoop</a> ();
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <span class="charliteral">'+'</span> :
        ++num_levels;
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <span class="charliteral">'-'</span> :
        <span class="keywordflow">if</span> ( num_levels &gt; 0 )
            --num_levels;
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <span class="charliteral">'r'</span> :  <span class="keywordflow">case</span> <span class="charliteral">'R'</span> :
        glMatrixMode ( GL_MODELVIEW );
        glLoadIdentity();
        xwin = -1.0;
        ywin = 0.0;
        glTranslated ( xwin, ywin, -5.0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">default</span>:
        need_redisplay = 0;
        <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">if</span> (need_redisplay)
        <a class="code" href="group__window.html#ga2">glutPostRedisplay</a>();
}

<span class="keyword">static</span> <span class="keywordtype">void</span> Special( <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )
{
    <span class="keywordtype">int</span> need_redisplay = 1;

    <span class="keywordflow">switch</span> (key) {
    <span class="keywordflow">case</span> GLUT_KEY_UP :
        glMatrixMode ( GL_MODELVIEW );
        ywin += 0.1 * scale_factor;
        glTranslated ( 0.0, 0.1 * scale_factor, 0.0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_DOWN :
        glMatrixMode ( GL_MODELVIEW );
        ywin -= 0.1 * scale_factor;
        glTranslated ( 0.0, -0.1 * scale_factor, 0.0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_LEFT :
        glMatrixMode ( GL_MODELVIEW );
        xwin -= 0.1 * scale_factor;
        glTranslated ( -0.1 * scale_factor, 0.0, 0.0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_RIGHT :
        glMatrixMode ( GL_MODELVIEW );
        xwin += 0.1 * scale_factor;
        glTranslated ( 0.1 * scale_factor, 0.0, 0.0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_PAGE_UP :
        glMatrixMode ( GL_MODELVIEW );
        glTranslated ( -xwin, -ywin, 0.0 );
        glScaled ( 1.25, 1.25, 1.25 );
        glTranslated ( xwin, ywin, 0.0 );
        scale_factor *= 0.8;
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_PAGE_DOWN :
        glMatrixMode ( GL_MODELVIEW );
        glTranslated ( -xwin, -ywin, 0.0 );
        glScaled ( 0.8, 0.8, 0.8 );
        glTranslated ( xwin, ywin, 0.0 );
        scale_factor *= 1.25;
        <span class="keywordflow">break</span>;

    <span class="keywordflow">default</span>:
        need_redisplay = 0;
        <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">if</span> (need_redisplay)
        <a class="code" href="group__window.html#ga2">glutPostRedisplay</a>();
}


<span class="keywordtype">void</span> readConfigFile ( <span class="keywordtype">char</span> *fnme )
{
    FILE *fptr = fopen ( fnme, <span class="stringliteral">"rt"</span> );
    <span class="keywordtype">int</span> i;
    <span class="keywordtype">char</span> inputline [ 256 ];

    <span class="keywordflow">if</span> ( fptr )
    {
        <span class="comment">/* Read a header line */</span>
        fgets( inputline, 256, fptr );

        <span class="comment">/* Read a comment line */</span>
        fgets( inputline, 256, fptr );

        <span class="comment">/* Read the window title */</span>
        fgets( inputline, 256, fptr );
        <span class="comment">/*</span>
<span class="comment">          We assume here that this line will not exceed 79 characters plus a</span>
<span class="comment">          newline (window_title is 80 characters long). That'll cause a buffer</span>
<span class="comment">          overflow. For a simple program like this, though, we're letting it</span>
<span class="comment">          slide!</span>
<span class="comment">        */</span>
        sscanf(
            inputline, <span class="stringliteral">"%[a-zA-Z0-9!@#$%^&amp;*()+=/\\_-\" ]"</span>, window_title
        );

        <span class="comment">/* Read a comment line */</span>
        fgets( inputline, 256, fptr );

        <span class="comment">/* Read the number of affine transformations */</span>
        fgets( inputline, 256, fptr );
        sscanf( inputline, <span class="stringliteral">"%d"</span>, &amp;num_trans );

        affine = (AffineTrans *)malloc ( num_trans * <span class="keyword">sizeof</span>(AffineTrans) );

        <span class="comment">/* Read a comment line */</span>
        fgets( inputline, 256, fptr );

        <span class="keywordflow">for</span> ( i = 0; i &lt; num_trans; i++ )
        {
            <span class="comment">/* Read an affine transformation definition */</span>
            fgets( inputline, 256, fptr );
            sscanf(
                inputline, <span class="stringliteral">"%lf %lf %lf %lf %lf %lf"</span>,
                &amp;affine[i].a00, &amp;affine[i].a01,
                &amp;affine[i].a10, &amp;affine[i].a11,
                &amp;affine[i].b0, &amp;affine[i].b1
            );
        }
    }
    <span class="keywordflow">else</span>  <span class="comment">/* No data file, set a default */</span>
    {
        printf( <span class="stringliteral">"ERROR opening file &lt;%s&gt;\n"</span>, fnme );
        strncpy( window_title, <span class="stringliteral">"Cantor Dust"</span>, WIN_TITLE_LENGTH );
        num_trans = 2;
        affine = (AffineTrans *)malloc ( num_trans * <span class="keyword">sizeof</span>(AffineTrans) );
        affine[0].a00 = 0.25;  affine[0].a01 = 0.00;
        affine[0].a10 = 0.00;  affine[0].a11 = 0.25;
        affine[0].b0 = 0.0;    affine[0].b1 = 0.0;
        affine[1].a00 = 0.25;  affine[1].a01 = 0.00;
        affine[1].a10 = 0.00;  affine[1].a11 = 0.25;
        affine[1].b0 = 0.5;    affine[1].b1 = 0.0;
    }

    <span class="keywordflow">for</span> ( i = 0; i &lt; num_trans; i++ )
    {
        <span class="keywordtype">double</span> m00, m01, m10, m11;  <span class="comment">/* Matrix "I" minus "A" */</span>
        <span class="keywordtype">double</span> determ;              <span class="comment">/* Determinant of this matrix */</span>

        <span class="comment">/* Calculate the stationary point */</span>

        m00 = 1.0 - affine[i].a00;
        m01 =     - affine[i].a01;
        m10 =     - affine[i].a10;
        m11 = 1.0 - affine[i].a11;

        determ = m00 * m11 - m01 * m10;

        <span class="keywordflow">if</span> ( fabs ( determ ) &gt; 1.e-6 )
        {
            affine[i].statx = (  m11 * affine[i].b0 - m01 * affine[i].b1 ) /
                determ;
            affine[i].staty = ( -m10 * affine[i].b0 + m00 * affine[i].b1 ) /
                determ;
        }
        <span class="keywordflow">else</span>
            affine[i].statx = affine[i].staty = 0.0;
    }
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="keywordtype">int</span> fractal_window;

    <a class="code" href="group__window.html#ga6">glutInitWindowSize</a>(500, 250);
    <a class="code" href="group__window.html#ga5">glutInitWindowPosition</a> ( 140, 140 );
    <a class="code" href="group__window.html#ga7">glutInitDisplayMode</a>(GLUT_RGB | GLUT_DOUBLE );
    <a class="code" href="group__mainloop.html#ga0">glutInit</a>(&amp;argc, argv);

    <span class="keywordflow">if</span> ( argc &gt; 1 )
        readConfigFile ( argv[1] );
    <span class="keywordflow">else</span>
        readConfigFile ( <span class="stringliteral">"fractals.dat"</span> );

    fractal_window = <a class="code" href="group__window.html#ga9">glutCreateWindow</a>( window_title );

    glClearColor( 1.0, 1.0, 1.0, 1.0 );

    <a class="code" href="group__windowcallback.html#ga1">glutReshapeFunc</a>( Reshape );
    <a class="code" href="group__input.html#ga0">glutKeyboardFunc</a>( Key );
    <a class="code" href="group__input.html#ga1">glutSpecialFunc</a>( Special );
    <a class="code" href="group__windowcallback.html#ga0">glutDisplayFunc</a>( Display );

    <a class="code" href="group__mainloop.html#ga2">glutMainLoop</a>( );

    printf( <span class="stringliteral">"Back from the 'freeglut' main loop\n"</span> );

    <span class="keywordflow">return</span> EXIT_SUCCESS;
}
</pre></div><br/><br/><br/><br/>
<div class="qindex">
<center><b>OpenGLUT Development @ Sourceforge</b></center>
<a class="qindex" href="http://openglut.sourceforge.net">Homepage</a> | 
<a class="qindex" href="http://sourceforge.net/projects/openglut/">Summary</a> | 
<a class="qindex" href="http://sourceforge.net/project/showfiles.php?group_id=104013">Files</a> | 
<a class="qindex" href="http://cvs.sourceforge.net/viewcvs.py/openglut">CVS</a> | 
<a class="qindex" href="http://sourceforge.net/forum/?group_id=104013">Forums</a> | 
<a class="qindex" href="http://sourceforge.net/mail/?group_id=104013">Lists</a> | 
<a class="qindex" href="http://sourceforge.net/tracker/?group_id=104013&atid=636633">Bugs</a> |
<a class="qindex" href="http://sourceforge.net/tracker/?group_id=104013&atid=636636">RFE</a>
</div>
<small>
<br/>
Generated on Tue Oct 5 18:44:22 2004 for OpenGLUT by
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.8<br/>
The OpenGLUT project is hosted by <a href="http://sourceforge.net">sourceforge.net</a>.
</small>
</body></html>
