<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="KeyWords" content="OpenGLUT, FreeGLUT, OpenGL, GLUT, X11, Windows, Programming, Documentation, Download, Development, Sourceforge">
<title>OpenGLUT 0.6.3 development - OpenGLUT: Window Management</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<div class="qindex">
<center><b>OpenGLUT Documentation</b></center>
<a class="qindex" style="font-size: 80%" href="index.html">Introduction</a>         | 
<a class="qindex" style="font-size: 80%" href="group__api.html">Documentation</a>   | 
<a class="qindex" style="font-size: 80%" href="group__examples.html">Examples</a>   |  
<a class="qindex" style="font-size: 80%" href="group__proposals.html">Proposals</a> |
<a class="qindex" style="font-size: 80%" href="authors.html">Authors</a>            | 
<a class="qindex" style="font-size: 80%" href="copying.html">Copying</a>            | 
<a class="qindex" style="font-size: 80%" href="todo.html">Todo</a>                  | 
<a class="qindex" style="font-size: 80%" href="bug.html">Bugs</a>                   | 
<a class="qindex" style="font-size: 80%" href="otherdoc.html">Links</a> 
</div>
<!-- Generated by Doxygen 1.3.8 -->
<h1>Window Management<br>
<small>
[<a class="el" href="group__api.html">OpenGLUT API Reference</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga10">glutCreateSubWindow</a> (int parentID, int x, int y, int w, int h)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga9">glutCreateWindow</a> (const char *title)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga11">glutDestroyWindow</a> (int windowID)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga21">glutFullScreen</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga13">glutGetWindow</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga24">glutGetWindowData</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga15">glutHideWindow</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga16">glutIconifyWindow</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga7">glutInitDisplayMode</a> (unsigned int displayMode)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga8">glutInitDisplayString</a> (const char *displayMode)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga5">glutInitWindowPosition</a> (int x, int y)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga6">glutInitWindowSize</a> (int width, int height)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga23">glutPopWindow</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga20">glutPositionWindow</a> (int x, int y)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga2">glutPostRedisplay</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga4">glutPostWindowRedisplay</a> (int windowID)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga22">glutPushWindow</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga19">glutReshapeWindow</a> (int width, int height)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga0">glutSetCursor</a> (int cursorID)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga18">glutSetIconTitle</a> (const char *title)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga12">glutSetWindow</a> (int ID)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga25">glutSetWindowData</a> (void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga17">glutSetWindowTitle</a> (const char *title)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga14">glutShowWindow</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga3">glutSwapBuffers</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__window.html#ga1">glutWarpPointer</a> (int x, int y)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
There are two kinds of windows available using OpenGLUT:<ul>
<li>Top-level windows</li><li>Subwindows</li></ul>
<p>
Each window has a unique identifier and OpenGL rendering context.<p>
This section describes the OpenGLUT API interface for creating, managing and closing windows. The section <a class="el" href="group__windowcallback.html">Window Callbacks</a> describes the callback handlers that applications can provide to customise the behaviour of each window.<p>
The desired position and size of a window is specified by <a class="el" href="group__window.html#ga5">glutInitWindowPosition()</a> and <a class="el" href="group__window.html#ga6">glutInitWindowSize()</a>. The display mode is specified by <a class="el" href="group__window.html#ga7">glutInitDisplayMode()</a> or <a class="el" href="group__window.html#ga8">glutInitDisplayString()</a> including RGBA color, double buffering, depth buffering and stencil buffering.<p>
Once created with <a class="el" href="group__window.html#ga9">glutCreateWindow()</a> windows can be controlled using:<p>
<ul>
<li><a class="el" href="group__window.html#ga14">glutShowWindow()</a> show the window</li><li><a class="el" href="group__window.html#ga15">glutHideWindow()</a> hide the window</li><li><a class="el" href="group__window.html#ga16">glutIconifyWindow()</a> iconify/minimize the window</li><li><a class="el" href="group__window.html#ga19">glutReshapeWindow()</a> resize the window</li><li><a class="el" href="group__window.html#ga20">glutPositionWindow()</a> reposition the window</li><li><a class="el" href="group__window.html#ga21">glutFullScreen()</a> make the window cover the entire screen</li><li><a class="el" href="group__window.html#ga22">glutPushWindow()</a> lower the current window in z</li><li><a class="el" href="group__window.html#ga23">glutPopWindow()</a> raise the current window in z</li><li><a class="el" href="group__window.html#ga2">glutPostRedisplay()</a> schedule a window redraw</li><li><a class="el" href="group__window.html#ga0">glutSetCursor()</a> set the window cursor</li><li><a class="el" href="group__window.html#ga1">glutWarpPointer()</a> position the window cursor</li><li><a class="el" href="group__window.html#ga3">glutSwapBuffers()</a> swap back buffer to the front</li></ul>
<p>
A window is closed by calling <a class="el" href="group__window.html#ga11">glutDestroyWindow()</a>.<p>
An application may open multiple top-level windows, each with optional subwindows. The <em>current</em> window is usually managed by the OpenGLUT event loop, but also be explicitly controlled:<p>
<ul>
<li><a class="el" href="group__window.html#ga12">glutSetWindow()</a> set the current window</li><li><a class="el" href="group__window.html#ga13">glutGetWindow()</a> get the current window</li></ul>
<p>
OpenGLUT also provides the ability for application data to be associated with each window:<p>
<ul>
<li><a class="el" href="group__window.html#ga24">glutGetWindowData()</a> get the application data</li><li><a class="el" href="group__window.html#ga25">glutSetWindowData()</a> set the application data </li></ul>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga10" doxytag="og_window.c::glutCreateSubWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int glutCreateSubWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>parentID</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>h</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a subwindow. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>parentID</em>&nbsp;</td><td>Parent window identifier </td></tr>
    <tr><td></td><td valign=top><em>x</em>&nbsp;</td><td>Horizontal position of subwindow </td></tr>
    <tr><td></td><td valign=top><em>y</em>&nbsp;</td><td>Vertical position of subwindow </td></tr>
    <tr><td></td><td valign=top><em>w</em>&nbsp;</td><td>Width of subwindow </td></tr>
    <tr><td></td><td valign=top><em>h</em>&nbsp;</td><td>Height of subwindow</td></tr>
  </table>
</dl>
In almost every regard that is important to you, a subwindow is like a top-level window. It has a window id; it has its own set of event callbacks; you can render to it; you are notified of its creation; ...<p>
A subwindow lives inside of some other window (possibly a top-level window, possibly another subwindow). Because of this, it generally only interacts with other windows of your own creation, hence it is not subjected to a window manager. This is the primary source for its differences from a top-level window:<p>
<ul>
<li>There are no borders or decorations.</li><li>There is no title bar, hence no title.</li><li>Requests tend to be acted on a little more directly, without interference from a window manager.</li><li>The subwindow inherits the display mode of its parent.</li></ul>
<p>
Like a top-level window, you <b>must</b> register a display callback function if you wish to use glutMainloop().<p>
A notable case where this function can fail is for offscreen windows. A coherent concept of a subwindow of an offscreen window would introduce more complication than is presently believed to be worthwhile. Attempting such a window presently just fails. Failure is denoted by a 0 <em>window id</em> being returned.<p>
Subwindows can be very useful for partitioning a window into GUI elements: They have their own input callbacks, so you don't have to figure out which window an event is for. Graphics are clipped to the boundaries of your subwindows, so you do not need to worry much about where your drawing goes. Because windows and subwindows work almost identically from the perspective of a GLUT program, it is relatively easy to move a cluster of related controls into a separate top-level window---or, conversely, embed what was a top-level window inside of another window. OpenGLUT can also report some basic statistics about your (sub)window, relieving you of the duty of tracking all of that information for yourself.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga9">glutCreateWindow()</a>, <a class="el" href="group__window.html#ga11">glutDestroyWindow()</a>, <a class="el" href="group__experimental.html#ga0">glutCreateMenuWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="og_window.c::glutCreateWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int glutCreateWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>title</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new top-level window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>title</em>&nbsp;</td><td>Title for created window</td></tr>
  </table>
</dl>
This function sends a request for a window to be constructed. OpenGLUT immediately constructs a data structure to track further events with the window, on the theory that eventually the window manager will get back to us with a real window. This allows us to begin registering callbacks immediately.<p>
In fact, you <b>must</b> register a display callback via <a class="el" href="group__windowcallback.html#ga0">glutDisplayFunc()</a> before you enter <a class="el" href="group__mainloop.html#ga2">glutMainLoop()</a>.<p>
For onscreen windows, you should not depend upon the window concretely existing or being visibile until you are told that it exists and is visible via a registered callback.<p>
The return value is an <em>int</em>. It should be positive for valid windows or 0 if failure occurred for some reason (Though traditional GLUT tends to bail out and abort rather than returning errors.) The integer is your <em>window id</em>. Old GLUT promises that these integers are ``small''; we do not reuse old <em>id</em>s, but do produce them sequentially.<p>
You can change the title later via <a class="el" href="group__window.html#ga17">glutSetWindowTitle()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga11">glutDestroyWindow()</a>, <a class="el" href="group__window.html#ga10">glutCreateSubWindow()</a>, <a class="el" href="group__window.html#ga17">glutSetWindowTitle()</a>, <a class="el" href="group__experimental.html#ga0">glutCreateMenuWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="og_window.c::glutDestroyWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutDestroyWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>windowID</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy a window and associated subwindows. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>windowID</em>&nbsp;</td><td>Window identifier</td></tr>
  </table>
</dl>
After this function is invoked, the only further event that may be delivered for your window is the one for its destruction. All other events should be discarded.<p>
Once a window has been destroyed, further attempts to use the window named by <em>windowID</em> are undefined. OpenGLUT generally tries to be sensible, and should not recycle the dead <em>windowID</em>, but you should treat a destroyed window much like a pointer to deallocated memory and try not to use it.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga9">glutCreateWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga21" doxytag="og_window.c::glutFullScreen" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutFullScreen           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resize the current window to cover the entire screen. 
<p>
The <a class="el" href="group__window.html#ga21">glutFullScreen()</a> function resizes the window to cover the entire screen and hide window decorations such as title bars and icons.<p>
<dl compact><dt><b>Note:</b></dt><dd>The desktop resolution is not affected by a call to <a class="el" href="group__window.html#ga19">glutReshapeWindow()</a> or <a class="el" href="group__window.html#ga21">glutFullScreen()</a>. <p>
The size of windows is ultimately determined by the windowing system. Therefore, a fullscreen request by an OpenGLUT application may not necessarily succeed or take immediate effect. <p>
Not applicable to offscreen or subwindows. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__mainloop.html#ga0">glutInit()</a>, <a class="el" href="group__window.html#ga5">glutInitWindowPosition()</a>, <a class="el" href="group__window.html#ga6">glutInitWindowSize()</a>, <a class="el" href="group__state.html#ga1">glutGet()</a>, <a class="el" href="group__window.html#ga20">glutPositionWindow()</a> and <a class="el" href="group__window.html#ga19">glutReshapeWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="og_window.c::glutGetWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int glutGetWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the current window identifier, 0 if undefined. 
<p>
<a class="el" href="group__window.html#ga13">glutGetWindow()</a> returns the <em>window id</em> of the <em>current window</em>. This is useful, e.g., if you have a generic function that is used with several windows and it needs to temporarily change to another window. (There is no window stack for you to use with pushes and pops. Do not be confused by <a class="el" href="group__window.html#ga22">glutPushWindow()</a> and <a class="el" href="group__window.html#ga23">glutPopWindow()</a>; those pushes and pops are <b>not</b> stack-related!)<p>
One cause for the function to return 0 is if you have called <a class="el" href="group__window.html#ga11">glutDestroyWindow()</a> on the <em>current window</em> and have done nothing to set a new window as current.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga12">glutSetWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga24" doxytag="og_window.c::glutGetWindowData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* glutGetWindowData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the user data for the current window. 
<p>
This function will return whatever <em>void*</em> value is associated with the <em>current window</em> via <a class="el" href="group__window.html#ga25">glutSetWindowData()</a>. This is <em>NULL</em> if you did not associate a pointer with your window. This can be useful in a situation where you have a single callback function performing services for many windows. You <b>could</b> keep track of the <em>window id</em>s in a global list and search for the <em>current window</em> in that list. But this is quicker than searching a data structure, and allows you to avoid the use of globals for this.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga25">glutSetWindowData()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="og_window.c::glutHideWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutHideWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make the current window hidden. 
<p>
Even if a window is ``open'', it need not be visible. It may be convenient to hide a window rather than to close it, if you want to re-display the window at the same location and size, later. Redefining all of the OpenGLUT features of a window and adding its <em>window id</em> to your tracking when re-opening a window may also be bothersome. So, rather than destroying it, you can simply ask for it to be hidden.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga14">glutShowWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="og_window.c::glutIconifyWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutIconifyWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Iconify the current window. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Applies only to onscreen, top-level windows. <p>
Not guaranteed to have any effect; effect may be arbitrarily delayed. <p>
There is no callback that specifically tells you when (or if) your window is iconified.</dd></dl>
Most window systems have some kind of ``minimized'' or ``iconified'' state for windows. All systems currently supported by OpenGLUT do so. The exact meaning of iconification is somewhat system-dependant, but this makes a request of the window system to place the window into this state.<p>
Graphic output is usually suspended in this form. User input may be partially or wholly suspended.<p>
If and when your window is iconified by the window system, it may be uniconified at any time by the system. This usually happens at the request of a user. Because of this, you should not use this function to hide a window. Rather, it is to help unclutter the user's display, and is more or less consensual with the user. Use <a class="el" href="group__window.html#ga15">glutHideWindow()</a> if you want to hide the window entirely.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga18">glutSetIconTitle()</a>, <a class="el" href="group__window.html#ga15">glutHideWindow()</a>, and <a class="el" href="group__window.html#ga14">glutShowWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="og_init.c::glutInitDisplayMode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutInitDisplayMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>displayMode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the window creation display mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>displayMode</em>&nbsp;</td><td>Requested display mode bitmask.</td></tr>
  </table>
</dl>
<a class="el" href="group__window.html#ga7">glutInitDisplayMode()</a> allows you to control the mode for subsequent OpenGLUT windows.<p>
Allowable <em>displayMode</em> is a combination of:<p>
<ul>
<li><em>GLUT_RGB</em> <br>
 Red, green, blue framebuffer.</li></ul>
<p>
<ul>
<li><em>GLUT_RGBA</em> <br>
 Red, green, blue, alpha framebuffer.</li></ul>
<p>
<ul>
<li><em>GLUT_INDEX</em> <br>
 Indexed color framebuffer.</li></ul>
<p>
<ul>
<li><em>GLUT_SINGLE</em> <br>
 Single-buffered mode.</li></ul>
<p>
<ul>
<li><em>GLUT_DOUBLE</em> <br>
 Double-buffered mode.</li></ul>
<p>
<ul>
<li><em>GLUT_ACCUM</em> <br>
 Accumulation buffer.</li></ul>
<p>
<ul>
<li><em>GLUT_ALPHA</em> <br>
 Alpha channel.</li></ul>
<p>
<ul>
<li><em>GLUT_DEPTH</em> <br>
 Depth buffering.</li></ul>
<p>
<ul>
<li><em>GLUT_STENCIL</em> <br>
 Stencil buffering.</li></ul>
<p>
<ul>
<li><em>GLUT_MULTISAMPLE</em> <br>
 Multisampling mode. (not always available)</li></ul>
<p>
<ul>
<li><em>GLUT_STEREO</em> <br>
 Left and right framebuffers.</li></ul>
<p>
<ul>
<li><em>GLUT_LUMINANCE</em> <br>
 Greyscale color mode.</li></ul>
<p>
Additionally, the following <em>experimental</em> features are implemented:<p>
<ul>
<li><em>GLUT_OFFSCREEN</em> <br>
 Offscreen windows are very much like onscreen windows that have been dragged off of the edge of the screen. The biggest issue is that offscreen windows do not support subwindows. Other than that, onscreen windows that are dragged off of the edge may not store graphics that you render (while <em>GLUT_OFFSCREEN</em> windows do), and there is no way to drag an offscreen window onscreen for user interaction.</li></ul>
<p>
<ul>
<li><em>GLUT_BORDERLESS</em> <br>
 Borderless windows are very experimental, and their precise behavior is not set in stone. See also <a class="el" href="group__experimental.html#ga0">glutCreateMenuWindow()</a>.</li></ul>
<p>
The following are <em>defaults</em>:<p>
<ul>
<li><em>GLUT_RGB</em> </li><li><em>GLUT_SINGLE</em> </li></ul>
<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000006">Bug:</a></b></dt><dd><em>GLUT_OFFSCREEN</em> windows do not work with nVidia cards/drivers. (Both Win32 and X11) <p>
<em>GLUT_BORDERLESS</em> seems to vary by the window manager on X11, though twm (for example) performs very similarly to WIN32. But KDE's window manager (for example) does not let you send keystrokes to borderless windows without OpenGLUT hacks. </dd></dl>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Some display mode features were introduced by OpenGLUT.<p>
Not all features or combinations of features are valid for all platforms.<p>
There is no way to change the display mode of an open window.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__experimental.html#ga0">glutCreateMenuWindow()</a>, <a class="el" href="group__mainloop.html#ga0">glutInit()</a>, <a class="el" href="group__window.html#ga6">glutInitWindowSize()</a>, <a class="el" href="group__window.html#ga5">glutInitWindowPosition()</a>, <a class="el" href="group__window.html#ga8">glutInitDisplayString()</a>, <a class="el" href="group__window.html#ga3">glutSwapBuffers()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="og_init.c::glutInitDisplayString" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutInitDisplayString           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>displayMode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the window creation display mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>displayMode</em>&nbsp;</td><td>Requested display mode string.</td></tr>
  </table>
</dl>
<a class="el" href="group__window.html#ga8">glutInitDisplayString()</a> permits you to define a display mode for subsequent windows that you open. In most regards, control is at least as fine as with glutInitDisplaymode().<p>
The <em>displayMode</em> parameter is case-sensitive, and tokens are separated by ASCII TABs (\t) and SPACEs.<p>
<ul>
<li><em>index</em> <br>
 Enables <em>GLUT_INDEX</em>.</li></ul>
<p>
<ul>
<li><em>luminance</em> <br>
 Enables <em>GLUT_LUMINANCE</em>. Enables <em>GLUT_STENCIL</em>.</li></ul>
<p>
<ul>
<li><em>red</em> <br>
 Number of red channel bits.</li></ul>
<p>
<ul>
<li><em>green</em> <br>
 Number of green channel bits.</li></ul>
<p>
<ul>
<li><em>blue</em> <br>
 Number of blue channel bits.</li></ul>
<p>
<ul>
<li><em>alpha</em> <br>
 Number of alpha channel bits. Enables <em>GLUT_ALPHA</em>.</li></ul>
<p>
<ul>
<li><em>rgb</em> <br>
 Number of <em>RGB</em> channel bits, no aplha bits. Enables <em>GLUT_RGB</em>.</li></ul>
<p>
<ul>
<li><em>rgba</em> <br>
 Number of <em>RGBA</em> channel bits. Enables <em>GLUT_RGBA</em>.</li></ul>
<p>
<ul>
<li><em>depth</em> <br>
 Number of depth buffer bits.</li></ul>
<p>
<ul>
<li><em>stencil</em> <br>
 Number of stencil buffer bits.</li></ul>
<p>
<ul>
<li><em>double</em> <br>
 Enables <em>GLUT_DOUBLE</em>.</li></ul>
<p>
<ul>
<li><em>single</em> <br>
 Enables <em>GLUT_SINGLE</em>.</li></ul>
<p>
<ul>
<li><em>stereo</em> <br>
 Enables <em>GLUT_STERO</em>.</li></ul>
<p>
<ul>
<li><em>acca</em> <br>
 Number of <em>RGBA</em> accumulation bits. Enables <em>GLUT_ACCUM</em>.</li></ul>
<p>
<ul>
<li><em>acc</em> <br>
 Number of <em>RGB</em> accumulation bits. Enables <em>GLUT_ACCUM</em>.</li></ul>
<p>
<ul>
<li><em>samples</em> <br>
 Number of samples for GLX's <em>SGIS_Multisample</em>. Enables <em>GLUT_MULTISAMPLE</em>.</li></ul>
<p>
<ul>
<li><em>buffer</em> <br>
 [TODO] Sets bits in index mode?</li></ul>
<p>
<ul>
<li><em>conformant</em> <br>
 [TODO] Conformant with what? Enables <em>GLUT_DEPTH</em>.</li></ul>
<p>
<ul>
<li><em>slow</em> <br>
 [TODO] Indicates if a frame-buffer is slow.</li></ul>
<p>
<ul>
<li><em>num</em> <br>
 [TODO] Appears to select a frame-buffer configuration by number from an unspecified list. Probably very non-portable.</li></ul>
<p>
A special capability name indicating where the value represents the Nth frame buffer configuration matching the description string<p>
<ul>
<li><em>win32pdf</em> <br>
 Win32 specific: Pixel Format Descriptor</li></ul>
<p>
<ul>
<li><em>win32pfd</em> <br>
 Win32 specific: Pixel Format Descriptor</li></ul>
<p>
<ul>
<li><em>xvisual</em> <br>
 X11 specific: X Visual</li></ul>
<p>
<ul>
<li><em>xstaticgray</em> <br>
 X11 specific: "staticgray" mode.</li></ul>
<p>
<ul>
<li><em>xgrayscale</em> <br>
 X11 specific: "grayscale" mode.</li></ul>
<p>
<ul>
<li><em>xstaticcolor</em> <br>
 X11 specific: "staticcolor" mode.</li></ul>
<p>
<ul>
<li><em>xpseudocolor</em> <br>
 X11 specific: "pseudocolor" mode.</li></ul>
<p>
<ul>
<li><em>xtruecolor</em> <br>
 X11 specific: "trueolor" mode.</li></ul>
<p>
<ul>
<li><em>xdirectcolor</em> <br>
 X11 specific: "directcolor" mode.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Conflicting modes, such as <em>single</em> and <em>double</em> have the same interaction as for <a class="el" href="group__window.html#ga7">glutInitDisplayMode()</a>.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd><em>GLUT_BORDERLESS</em> and <em>GLUT_OFFSCREEN</em> are not represented. <p>
Not all features appear to be implemented. In particular, numeric parameters and comparator specifications are lacking. See GLUT 3.7 sources for example. <p>
PyOpenGL <a href="http://pyopengl.sourceforge.net/documentation/manual/glutInitDisplayString.3GLUT.html">glutInitDisplayString</a> documentation. </dd></dl>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__mainloop.html#ga0">glutInit()</a>, <a class="el" href="group__window.html#ga5">glutInitWindowPosition()</a>, <a class="el" href="group__window.html#ga6">glutInitWindowSize()</a>, <a class="el" href="group__window.html#ga7">glutInitDisplayMode()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="og_init.c::glutInitWindowPosition" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutInitWindowPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Requests future windows to open at a given position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>x</em>&nbsp;</td><td>X coordinate. </td></tr>
    <tr><td></td><td valign=top><em>y</em>&nbsp;</td><td>Y coordinate.</td></tr>
  </table>
</dl>
This function allows you to request an initial position for future windows.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga20">glutPositionWindow()</a>, <a class="el" href="group__mainloop.html#ga0">glutInit()</a>, <a class="el" href="group__window.html#ga6">glutInitWindowSize()</a>, <a class="el" href="group__window.html#ga7">glutInitDisplayMode()</a>, <a class="el" href="group__window.html#ga8">glutInitDisplayString()</a>, <a class="el" href="group__state.html#ga1">glutGet()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="og_init.c::glutInitWindowSize" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutInitWindowSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Requests future windows to open at a given width/height.. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>width</em>&nbsp;</td><td>Width of future windows. </td></tr>
    <tr><td></td><td valign=top><em>height</em>&nbsp;</td><td>Height of future windows.</td></tr>
  </table>
</dl>
This function allows you to request initial dimensions for future windows.<p>
There is a callback function to inform you of the new window shape (whether initially opened, changed by your <a class="el" href="group__window.html#ga19">glutReshapeWindow()</a> request, or changed directly by the user). <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga19">glutReshapeWindow()</a>, <a class="el" href="group__mainloop.html#ga0">glutInit()</a>, <a class="el" href="group__window.html#ga5">glutInitWindowPosition()</a>, <a class="el" href="group__window.html#ga7">glutInitDisplayMode()</a>, <a class="el" href="group__window.html#ga8">glutInitDisplayString()</a>, glutReshapeFunc(), <a class="el" href="group__state.html#ga1">glutGet()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga23" doxytag="og_window.c::glutPopWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutPopWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request to raise the current window to the top. 
<p>
Request that the <em>current window</em> be brought to the top.<p>
A window can be in front of or behind other windows, as determined by the z-order from front to back. Top-level OpenGLUT windows can be placed at the front or back of the z-order by means of the <a class="el" href="group__window.html#ga23">glutPopWindow()</a> and <a class="el" href="group__window.html#ga22">glutPushWindow()</a> API functions.<p>
A z-order also applies to the subwindows of a top-level window. While the z-order of top-level windows can usually be adjusted by the user, subwindow z-order is controlled entirely by the application.<p>
If this has any effect on your window's visibility, you should receive a glutWindowStatusFunc() callback and a <a class="el" href="group__windowcallback.html#ga0">glutDisplayFunc()</a> callback.<p>
<dl compact><dt><b>Note:</b></dt><dd>The z-order of top-level windows is ultimately managed by the windowing system. Therefore, a push or pop request by an OpenGLUT application may not necessarily succeed or take immediate effect. <p>
Not applicable to offscreen windows. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga9">glutCreateWindow()</a>, <a class="el" href="group__windowcallback.html#ga0">glutDisplayFunc()</a>, <a class="el" href="group__window.html#ga22">glutPushWindow()</a>, glutWindowStatusFunc() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga20" doxytag="og_window.c::glutPositionWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutPositionWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request to change the position of the current window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>x</em>&nbsp;</td><td>Requested horizontal position of the current window </td></tr>
    <tr><td></td><td valign=top><em>y</em>&nbsp;</td><td>Requested vertical position of the current window</td></tr>
  </table>
</dl>
The <a class="el" href="group__window.html#ga20">glutPositionWindow()</a> function requests that the window system position a top-level or subwindow relative to the top-left corner. Subwindows are typically resized and repositioned in response to window resize events.<p>
<dl compact><dt><b>Note:</b></dt><dd>The position of top-level windows is ultimately determined by the windowing system. Therefore, a position request by an OpenGLUT application may not necessarily succeed. <p>
May not take immediate effect; wait for the callback. <p>
Not applicable to offscreen windows. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__mainloop.html#ga0">glutInit()</a>, <a class="el" href="group__window.html#ga5">glutInitWindowPosition()</a>, glutReshapeFunc(), and <a class="el" href="group__window.html#ga10">glutCreateSubWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="og_display.c::glutPostRedisplay" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutPostRedisplay           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mark the current window as needing a redisplay. 
<p>
Whenever circumstances indicate that your window is in need of being redisplayed, you may call <a class="el" href="group__window.html#ga2">glutPostRedisplay()</a> to tell OpenGLUT that you want to redraw your graphics. Multiple calls to this function may be coalesced by OpenGLUT to avoid excessive invocation of your drawing support.<p>
The ultimate effect of this function is to call your Display callback for the <em>current window</em>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga4">glutPostWindowRedisplay()</a>, <a class="el" href="group__overlays.html#ga3">glutPostOverlayRedisplay()</a>, <a class="el" href="group__overlays.html#ga4">glutPostWindowOverlayRedisplay()</a>, <a class="el" href="group__window.html#ga3">glutSwapBuffers()</a>, <a class="el" href="group__windowcallback.html#ga0">glutDisplayFunc()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="og_display.c::glutPostWindowRedisplay" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutPostWindowRedisplay           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>windowID</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mark an indicated window as needing a redisplay. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>windowID</em>&nbsp;</td><td>The OpenGLUT window id to be affected.</td></tr>
  </table>
</dl>
Similar to <a class="el" href="group__window.html#ga2">glutPostRedisplay()</a>, except that instead of affecting the <em>current window</em>, this function affects an arbitrary window, indicated by the <em>windowID</em> parameter.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga2">glutPostRedisplay()</a>, <a class="el" href="group__overlays.html#ga3">glutPostOverlayRedisplay()</a>, <a class="el" href="group__overlays.html#ga4">glutPostWindowOverlayRedisplay()</a>, <a class="el" href="group__window.html#ga3">glutSwapBuffers()</a>, <a class="el" href="group__windowcallback.html#ga0">glutDisplayFunc()</a>, <a class="el" href="group__window.html#ga9">glutCreateWindow()</a>, <a class="el" href="group__window.html#ga10">glutCreateSubWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga22" doxytag="og_window.c::glutPushWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutPushWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request to lower the current window to the bottom. 
<p>
This function requests that the <em>current window</em> be ``pushed'' to the back.<p>
A window can be in front of or behind other windows, as determined by the z-order from front to back. Top-level OpenGLUT windows can be placed at the front or back of the z-order by means of the <a class="el" href="group__window.html#ga23">glutPopWindow()</a> and <a class="el" href="group__window.html#ga22">glutPushWindow()</a> API functions.<p>
A z-order also applies to the subwindows of a top-level window. While the z-order of top-level windows can usually be adjusted by the user, subwindow z-order is controlled entirely by the application.<p>
There may not be an immediate effect to this function. Wait for the glutWindowStatusFunc() callback to tell you about whatever obscured/visible status your window achieves.<p>
<dl compact><dt><b>Note:</b></dt><dd>The z-order of top-level windows is ultimately managed by the windowing system. Therefore, a push or pop request by an OpenGLUT application may not necessarily succeed or take immediate effect. <p>
Not applicable to offscreen windows. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga23">glutPopWindow()</a>, glutWindowStatusFunc() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="og_window.c::glutReshapeWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutReshapeWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request changing the size of the current window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>width</em>&nbsp;</td><td>Requested width of the current window </td></tr>
    <tr><td></td><td valign=top><em>height</em>&nbsp;</td><td>Requested height of the current window</td></tr>
  </table>
</dl>
The <a class="el" href="group__window.html#ga19">glutReshapeWindow()</a> function adjusts the width and height of the <em>current window</em>, if it is an onscreen top-level or subwindow. Subwindows are typically resized and repositioned in response to window resize events.<p>
The window system may delay or even alter your request. Use the glutReshapeFunc() callback registration for the window if you want<p>
If you try to make a subwindow smaller than its parent, the parent will not grow to accomodate the child.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd>Add support for offscreen windows.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__mainloop.html#ga0">glutInit()</a>, <a class="el" href="group__window.html#ga6">glutInitWindowSize()</a>, glutReshapeFunc() and <a class="el" href="group__window.html#ga10">glutCreateSubWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="og_cursor.c::glutSetCursor" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutSetCursor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cursorID</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the cursor image to be used for the current window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>cursorID</em>&nbsp;</td><td>Name of desired cursor.</td></tr>
  </table>
</dl>
For the <em>current window</em>, sets the mouse-cursor to one of a set of predefined images. The GLUT symbolic constant IDs are:<p>
<ul>
<li><em>GLUT_CURSOR_RIGHT_ARROW</em> </li><li><em>GLUT_CURSOR_LEFT_ARROW</em> </li><li><em>GLUT_CURSOR_INFO</em> </li><li><em>GLUT_CURSOR_DESTROY</em> </li><li><em>GLUT_CURSOR_HELP</em> </li><li><em>GLUT_CURSOR_CYCLE</em> </li><li><em>GLUT_CURSOR_SPRAY</em> </li><li><em>GLUT_CURSOR_WAIT</em> </li><li><em>GLUT_CURSOR_TEXT</em> </li><li><em>GLUT_CURSOR_CROSSHAIR</em> </li><li><em>GLUT_CURSOR_UP_DOWN</em> </li><li><em>GLUT_CURSOR_LEFT_RIGHT</em> </li><li><em>GLUT_CURSOR_TOP_SIDE</em> </li><li><em>GLUT_CURSOR_BOTTOM_SIDE</em> </li><li><em>GLUT_CURSOR_LEFT_SIDE</em> </li><li><em>GLUT_CURSOR_RIGHT_SIDE</em> </li><li><em>GLUT_CURSOR_TOP_LEFT_CORNER</em> </li><li><em>GLUT_CURSOR_TOP_RIGHT_CORNER</em> </li><li><em>GLUT_CURSOR_BOTTOM_RIGHT_CORNER</em> </li><li><em>GLUT_CURSOR_BOTTOM_LEFT_CORNER</em> </li></ul>
<p>
Additionally, there are the following special cases:<p>
<em>GLUT_CURSOR_FULL_CROSSHAIR</em> This cursor, where supported, draws a crosshair the full width and height of the display. It may be mapped by OpenGLUT to the <em>GLUT_CURSOR_CROSSHAIR</em>, however.<p>
<em>GLUT_CURSOR_NONE</em> Turn the mouse cursor invisibile.<p>
<em>GLUT_CURSOR_INHERIT</em> Take the cursor that the parent window provides.<p>
<dl compact><dt><b>Note:</b></dt><dd>The X branch of OpenGLUT does not do thorough error checking. <p>
The X branch of OpenGLUT always converts <em>FULL_CROSSHAIR</em> to <em>CROSSHAIR</em>. This is acceptable, but if a host system supports a fullscreen crosshair, it would be nice to support that. <p>
Out of range <em>cursorID</em> values generate warnings. <p>
Has no visible effect if the <em>current window</em> is of type <em>GLUT_OFFSCREEN</em> . </dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>Some <em>cursorID</em> values are not yet supported on WIN32. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga18" doxytag="og_window.c::glutSetIconTitle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutSetIconTitle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>title</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Requests changing the iconified title of the current window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>title</em>&nbsp;</td><td>New window title </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Effect is system-dependant.</dd></dl>
Requests that the window system change the title of the icon (or whatever) that is displayed when the <em>current window</em> is in iconified mode.<p>
As discussed under <a class="el" href="group__window.html#ga16">glutIconifyWindow()</a>, most window systems allow a window to be placed in some kind of minimized, or iconified, state. In that state, the normal interior of the window is likely to be obscured, and the only clue about the window contents may be the window title.<p>
<dl compact><dt><b>Note:</b></dt><dd>There Exactly what "iconified" means is system dependant. Iconification may not be supported, or the title may not be available---or legible. Avoid putting essential information into the icon title. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga17">glutSetWindowTitle()</a>, <a class="el" href="group__window.html#ga16">glutIconifyWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="og_window.c::glutSetWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutSetWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ID</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Select the <em>current window</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>ID</em>&nbsp;</td><td>Window identifier</td></tr>
  </table>
</dl>
Sets the <em>current window</em> to <em>ID</em>.<p>
All OpenGL rendering goes to the <em>current window</em>. Many OpenGLUT functions also implicitly use the <em>current window</em>.<p>
Many OpenGLUT callback operations are tied to a window. When your callback is invoked, OpenGLUT will set that particular window to be the <em>current window</em>. However, some callbacks---such as that registered via <a class="el" href="group__idletimer.html#ga0">glutIdleFunc()</a>---do not have associated windows. If a callback is not associated to a particular window, then when OpenGLUT invokes that callback you should <b>always</b> use <a class="el" href="group__window.html#ga12">glutSetWindow()</a> to select the appropriate window before doing any OpenGL rendering or doing any OpenGLUT window-related operations.<p>
There may be cases when you can get away with assuming that the <em>current window</em> is unchanged since some prior time, but OpenGLUT has considerable liberaty with respect to when it invokes your functions. Also, your program may add more windows or more operations on other windows as you develop it.<p>
Lastly, this is a convenient way to select among multiple windows for drawing without actually waiting for that window's display callback. Simply set the <em>current window</em> and draw immediately. This is not always advisable, but may be practical.<p>
It is an error to set the <em>current window</em> to a non-existant window (e.g., one that you have closed). A warning will be printed on <em>stderr</em> if you try to do so, and the <em>current window</em> should be unchanged.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga13">glutGetWindow()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga25" doxytag="og_window.c::glutSetWindowData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutSetWindowData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>data</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the user data for the current window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>data</em>&nbsp;</td><td>Arbitrary client-supplied pointer.</td></tr>
  </table>
</dl>
This associates an arbitrary <em>void*</em> value with the <em>current window</em>. This is especially useful in client-side callbacks that service many windows, if the client needs to know more about the window than OpenGLUT normally will provide.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga24">glutGetWindowData()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="og_window.c::glutSetWindowTitle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutSetWindowTitle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>title</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request changing the title of the current window. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>title</em>&nbsp;</td><td>New window title </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Only for managed, onscreen, top-level windows. <p>
Not all window systems display titles. <p>
May be ignored or delayed by window manager.</dd></dl>
<a class="el" href="group__window.html#ga17">glutSetWindowTitle()</a> requests that the window system change the title of the window.<p>
Normally a window system displays a title for every top-level window in the system. The initial title is set when you call <a class="el" href="group__window.html#ga9">glutCreateWindow()</a>. By means of this function you can set the titles for your top-level OpenGLUT windows.<p>
Some window systems do not provide titles for windows, in which case this function may have no useful effect.<p>
Because the effect may be delayed or lost, you should not count on the effect of this function. However, it can be a nice touch to use the window title bar for a one-line status bar in some cases. Use discretion.<p>
If you just want one title for the window over the window's entire life, you should set it when you open the window with <a class="el" href="group__window.html#ga9">glutCreateWindow()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga9">glutCreateWindow()</a>, <a class="el" href="group__window.html#ga18">glutSetIconTitle()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="og_window.c::glutShowWindow" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutShowWindow           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request that the <em>current window</em> be visible. 
<p>
<a class="el" href="group__window.html#ga14">glutShowWindow()</a> requests that the window system make the <em>current window</em> visible.<p>
This is generally not necessary. When you create a window, it will normally become visible. Unless you specifically hide it, it will remain visible. Though visible, of course, it may be covered by other windows; that would be an issue for window stacking order not visibility.<p>
When, and if, your window's visibility status changes, you may find out via a glutWindowStatusFunc() callback.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga15">glutHideWindow()</a>, <a class="el" href="group__window.html#ga23">glutPopWindow()</a>, <a class="el" href="group__window.html#ga22">glutPushWindow()</a>, glutWindowStatusFunc() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="og_display.c::glutSwapBuffers" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutSwapBuffers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Swaps the buffers for the current window. 
<p>
This function signals to OpenGLUT that you are done drawing to the <em>current window</em> for now. If your window is double-buffered (<em>GLUT_DOUBLE</em> param to <a class="el" href="group__window.html#ga7">glutInitDisplayMode()</a>), then OpenGLUT will swap the front buffer with the back buffer.<p>
This also computes your current frame-rate and prints the result on <em>stderr</em> if indicated by the <em>GLUT_FPS</em> environment variable. The computed value is not necessarily the total frame rate, if you have multiple windows, as the statistic is the total number of buffer-swaps for the entire program.<p>
<dl compact><dt><b>Note:</b></dt><dd>This function has no effect if your window is <em>GLUT_SINGLE</em> . <p>
Frame rate is only calculated for double-buffered windows. </dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>How does this interact with overlays? <p>
Consider making <em>GLUT_FPS</em> keep per-window stats in a multi-window program.</dd></dl>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__window.html#ga2">glutPostRedisplay()</a>, <a class="el" href="group__overlays.html#ga3">glutPostOverlayRedisplay()</a>, <a class="el" href="group__window.html#ga4">glutPostWindowRedisplay()</a>, <a class="el" href="group__overlays.html#ga4">glutPostWindowOverlayRedisplay()</a>, glutInitDisplaymode() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="og_cursor.c::glutWarpPointer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void glutWarpPointer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Moves the mouse pointer to given window coordinates. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>x</em>&nbsp;</td><td>Window X coord for mouse. </td></tr>
    <tr><td></td><td valign=top><em>y</em>&nbsp;</td><td>Window Y coord for mouse.</td></tr>
  </table>
</dl>
<a class="el" href="group__window.html#ga1">glutWarpPointer()</a> moves the mouse pointer to window-relative coordinates given by <em>x</em> and <em>y</em>.<p>
<dl compact><dt><b>Note:</b></dt><dd><em>x</em> and <em>y</em> are relative to current window. <p>
Not applicable for <em>GLUT_OFFSCREEN</em> windows. <p>
Warping means moving, just as if the user had manually moved the mouse. This can generate mouse-motion callbacks. If your callback then moves the pointer again, you may end up in an endless loop. There is some discussion about changing this, but at present this is just a caveat for you, the user, to be aware of. </dd></dl>
    </td>
  </tr>
</table>
<br/><br/><br/><br/>
<div class="qindex">
<center><b>OpenGLUT Development @ Sourceforge</b></center>
<a class="qindex" href="http://openglut.sourceforge.net">Homepage</a> | 
<a class="qindex" href="http://sourceforge.net/projects/openglut/">Summary</a> | 
<a class="qindex" href="http://sourceforge.net/project/showfiles.php?group_id=104013">Files</a> | 
<a class="qindex" href="http://cvs.sourceforge.net/viewcvs.py/openglut">CVS</a> | 
<a class="qindex" href="http://sourceforge.net/forum/?group_id=104013">Forums</a> | 
<a class="qindex" href="http://sourceforge.net/mail/?group_id=104013">Lists</a> | 
<a class="qindex" href="http://sourceforge.net/tracker/?group_id=104013&atid=636633">Bugs</a> |
<a class="qindex" href="http://sourceforge.net/tracker/?group_id=104013&atid=636636">RFE</a>
</div>
<small>
<br/>
Generated on Tue Oct 5 18:44:33 2004 for OpenGLUT by
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.8<br/>
The OpenGLUT project is hosted by <a href="http://sourceforge.net">sourceforge.net</a>.
</small>
</body></html>
