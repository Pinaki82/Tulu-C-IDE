<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="KeyWords" content="OpenGLUT, FreeGLUT, OpenGL, GLUT, X11, Windows, Programming, Documentation, Download, Development, Sourceforge">
<title>OpenGLUT 0.6.3 development - OpenGLUT: offscreen.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<div class="qindex">
<center><b>OpenGLUT Documentation</b></center>
<a class="qindex" style="font-size: 80%" href="index.html">Introduction</a>         | 
<a class="qindex" style="font-size: 80%" href="group__api.html">Documentation</a>   | 
<a class="qindex" style="font-size: 80%" href="group__examples.html">Examples</a>   |  
<a class="qindex" style="font-size: 80%" href="group__proposals.html">Proposals</a> |
<a class="qindex" style="font-size: 80%" href="authors.html">Authors</a>            | 
<a class="qindex" style="font-size: 80%" href="copying.html">Copying</a>            | 
<a class="qindex" style="font-size: 80%" href="todo.html">Todo</a>                  | 
<a class="qindex" style="font-size: 80%" href="bug.html">Bugs</a>                   | 
<a class="qindex" style="font-size: 80%" href="otherdoc.html">Links</a> 
</div>
<!-- Generated by Doxygen 1.3.8 -->
<h1>offscreen.c File Reference</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
OpenGLUT offscreen rendering demo.<p>
Usage:<p>
offscreen [standard GLUT options] [filename]<p>
<pre>
      Touch-type
          on the teapot
      with me.
      </pre><p>
Normal printable ASCII characters work as might be expected. The return and backspace keys also work for editing.<p>
^S Saves a PNM image of the window to <em>filename</em><p>
The filename specifies the output PNM image file, the default is "offscreen.pnm".<p>
PNM files are widely supported in image editing and viewing appliations such as The Gimp.<p>
Some suggested uses for GLUT_OFFSCREEN:<ul>
<li>Reliable capturing of OpenGL screen shots.</li><li>Image output applications, tools and languages.</li><li>Texture generation.</li><li>Make stencils.</li><li>Height field generation.</li><li>Poster texture generation (e.g., for pasting onto a video screen)</li><li>Textured imposter generation.</li><li>Rendering to a high resolution bitmap for printing.</li></ul>
<p>
<dl compact><dt><b>Author:</b></dt><dd>Copyright (C) 2004, the OpenGLUT project contributors.</dd></dl>
<div align="center">
<img src="openglut_offscreen.png" alt="openglut_offscreen.png">
<p><strong>OpenGLUT Offscreen Rendering Demonstration</strong></p></div>
 <div class="fragment"><pre>
<span class="preprocessor">#include &lt;GL/openglut.h&gt;</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="keywordtype">int</span> offscreen_id;
<span class="keywordtype">int</span> onscreen_id;

<span class="comment">/*</span>
<span class="comment"> * The filename to which to save PNM screenshots.</span>
<span class="comment"> * Can be overridden by a commandline option.</span>
<span class="comment"> *</span>
<span class="comment"> * Save images with a ^S.</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *save_file_name = <span class="stringliteral">"offscreen.pnm"</span>;

<span class="keyword">static</span> GLuint texName;

<span class="keywordtype">double</span> theta = 0;


<span class="comment">/*</span>
<span class="comment"> * Our text block.  80x25 is standard for a console, so why not?</span>
<span class="comment"> * Though with a 15-pixel font, you get more like 28x8.  The</span>
<span class="comment"> * terminal size should probably be computed at runtime from the</span>
<span class="comment"> * texture dimensions, which should be a user parameter.  Oh well.</span>
<span class="comment"> */</span>
<span class="preprocessor">#define ROWS 25</span>
<span class="preprocessor"></span><span class="preprocessor">#define COLS 80</span>
<span class="preprocessor"></span><span class="keywordtype">char</span> text[ ROWS ][ COLS+2 ];
<span class="preprocessor">#define OFFSCREEN_W 256</span>
<span class="preprocessor"></span><span class="preprocessor">#define OFFSCREEN_H 128</span>
<span class="preprocessor"></span>
<span class="keywordtype">void</span> write_raw_pnm( <span class="keyword">const</span> <span class="keywordtype">char</span> *fname, <span class="keywordtype">char</span> *pixels, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h )
{
    FILE *f;

    f = fopen( fname, <span class="stringliteral">"wb"</span> );
    <span class="keywordflow">if</span>( !f )
        printf( <span class="stringliteral">"Ouch!  Cannot create file.\n"</span> );
    <span class="keywordflow">else</span>
    {
        <span class="keywordtype">int</span> row;

        fprintf( f, <span class="stringliteral">"P6\n"</span> );
        fprintf( f, <span class="stringliteral">"# CREATOR: offscreen freeglut demo\n"</span> );
        fprintf( f, <span class="stringliteral">"%d %d\n"</span>, w, h );
        fprintf( f, <span class="stringliteral">"255\n"</span> );

        <span class="comment">/*</span>
<span class="comment">         * Write the rows in reverse order because OpenGL's 0th row</span>
<span class="comment">         * is at the bottom.</span>
<span class="comment">         */</span>
        <span class="keywordflow">for</span>( row = h; row; --row )
            fwrite( pixels + ((row - 1)*w*3), 1, 3 * w, f );

        fclose( f );
    }
}

<span class="keywordtype">void</span> save_window( <span class="keyword">const</span> <span class="keywordtype">char</span> *file_name )
{
    <span class="keywordtype">char</span> *pixels;
    <span class="keywordtype">int</span> width  = <a class="code" href="group__state.html#ga1">glutGet</a>( GLUT_WINDOW_WIDTH );
    <span class="keywordtype">int</span> height = <a class="code" href="group__state.html#ga1">glutGet</a>( GLUT_WINDOW_HEIGHT );
    pixels = malloc( 3 * width * height);
    <span class="keywordflow">if</span>( pixels )
    {
        glPixelStorei( GL_PACK_ALIGNMENT, 1 );
        glReadPixels(
            0, 0, width, height,
            GL_RGB, GL_UNSIGNED_BYTE, (GLvoid *)pixels
        );
        write_raw_pnm( file_name, pixels, width, height );
    }
}


<span class="keywordtype">void</span> cb_idle( <span class="keywordtype">void</span> )
{
    <a class="code" href="group__window.html#ga12">glutSetWindow</a>( onscreen_id );
    <a class="code" href="group__window.html#ga2">glutPostRedisplay</a>( );
}

<span class="keywordtype">void</span> cb_offscreen_display( <span class="keywordtype">void</span> )
{
    <span class="keyword">static</span> <span class="keywordtype">char</span> pixels [OFFSCREEN_W * OFFSCREEN_H * 3];
    <span class="keywordtype">int</span> i;

    glEnable( GL_DEPTH_TEST );

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    glColor3d( 1.0, 0, 0 );
    glPushMatrix( );
    glRotated( .0071234 * <a class="code" href="group__state.html#ga1">glutGet</a>( GLUT_ELAPSED_TIME ), 0, 1, 0 );
    <a class="code" href="group__geometry.html#ga9">glutSolidTorus</a>( .2, .6, 20, 20 );
    glPopMatrix( );

    glDisable( GL_LIGHTING );
    glMatrixMode( GL_PROJECTION );
    glPushMatrix( );
    glLoadIdentity( );
    glColor3d( 0.0, 1.0, 0.0 );
    glRasterPos2f( -1, 1 - ( ( 2.0 * 10 ) / OFFSCREEN_H ) );
    glNormal3d( 0, 0, 1 );
    <span class="keywordflow">for</span>( i = 7; i &gt; -1; --i )
        <a class="code" href="group__bitmapfont.html#ga1">glutBitmapString</a>( GLUT_BITMAP_9_BY_15, text[ i ] );
    
    glPopMatrix( );
    glMatrixMode( GL_MODELVIEW );
    glEnable( GL_LIGHTING );

    glReadPixels(
        0, 0, OFFSCREEN_W, OFFSCREEN_H,
        GL_RGB, GL_UNSIGNED_BYTE, (GLvoid *)pixels
    );
    <a class="code" href="group__window.html#ga12">glutSetWindow</a>( onscreen_id );
    glBindTexture( GL_TEXTURE_2D, texName );
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
    glTexImage2D (
        GL_TEXTURE_2D, 0, GL_RGB, OFFSCREEN_W, OFFSCREEN_H,
        0, GL_RGB, GL_UNSIGNED_BYTE, (<span class="keywordtype">void</span> *)pixels
    );
    glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
    glDisable( GL_DEPTH_TEST );
}

<span class="keywordtype">void</span> cb_onscreen_display( <span class="keywordtype">void</span> )
{
    <span class="keyword">const</span> <span class="keyword">static</span> GLfloat flip_it_matrix[ 16 ] =
        { -1, 0, 0, 0,
          0, -1, 0, 0,
          0,  0, 1, 0,
          0,  0, 0, 1
        };

    <a class="code" href="group__window.html#ga12">glutSetWindow</a>( offscreen_id );
    cb_offscreen_display( );

    glDisable( GL_LIGHTING );
    glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT );
    glColor3d( 1.0, 0.0, 0.0 );
    glBegin( GL_LINE_LOOP );
    glVertex2d( 0.0, 0.0 );
    glVertex2d( 0.5, 0.0 );
    glVertex2d( 0.5, 0.5 );
    glVertex2d( 0.0, 0.5 );
    glVertex2d( 0.0, 0.0 );
    glEnd( );
    glColor3d( 1.0, 1.0, 1.0 );
    glRasterPos2d( -2.0, 0.8 );
    <a class="code" href="group__bitmapfont.html#ga1">glutBitmapString</a>(
        GLUT_BITMAP_TIMES_ROMAN_24, <span class="stringliteral">"Press ^S to Send to"</span>
    );
    glRasterPos2d( -1.8, 0.6 );
    <a class="code" href="group__bitmapfont.html#ga1">glutBitmapString</a>( GLUT_BITMAP_TIMES_ROMAN_24, <span class="stringliteral">"'"</span> );
    <a class="code" href="group__bitmapfont.html#ga1">glutBitmapString</a>(
        GLUT_BITMAP_9_BY_15, save_file_name );
    <a class="code" href="group__bitmapfont.html#ga1">glutBitmapString</a>( GLUT_BITMAP_TIMES_ROMAN_24, <span class="stringliteral">"'"</span> );
    glRasterPos2d( -2.0, 0.3 );
    <a class="code" href="group__bitmapfont.html#ga1">glutBitmapString</a>(
        GLUT_BITMAP_TIMES_ROMAN_24, <span class="stringliteral">"Press Esc to quit."</span>
    );

    glEnable( GL_DEPTH_TEST );
    glEnable( GL_TEXTURE_2D );
    glBindTexture( GL_TEXTURE_2D, texName );
    glBegin( GL_QUADS );
      glNormal3f( 0, 0, -1 );
      glTexCoord2i( 0, 0 ); glVertex3i( -9, -9, -4 );
      glTexCoord2i( 1, 0 ); glVertex3i(  9, -9, -4 );
      glTexCoord2i( 1, 1 ); glVertex3i(  9,  9, -4 );
      glTexCoord2i( 0, 1 ); glVertex3i( -9,  9, -4 );
      glTexCoord2i( 0, 0 ); glVertex3i( -9, -9, -4 );
    glEnd( );

    glEnable( GL_LIGHTING );
    glDisable( GL_LIGHTING );
    glPushMatrix( );
    theta = .01 * <a class="code" href="group__state.html#ga1">glutGet</a>( GLUT_ELAPSED_TIME );
    glRotated( theta, 0, 1, 0 );
    glMatrixMode( GL_TEXTURE );
    glLoadMatrixf( flip_it_matrix );
    glMatrixMode( GL_MODELVIEW );
    <a class="code" href="group__geometry.html#ga23">glutSolidTeapot</a>( 1.0 );
    glMatrixMode( GL_TEXTURE );
    glLoadIdentity( );
    glMatrixMode( GL_MODELVIEW );
    glDisable( GL_TEXTURE_2D );
    glPopMatrix( );
    glDisable( GL_DEPTH_TEST );

    <a class="code" href="group__window.html#ga3">glutSwapBuffers</a>( );
}




<span class="keyword">static</span> <span class="keywordtype">int</span> cursor;
<span class="keywordtype">void</span> vscroll( <span class="keywordtype">void</span> )
{
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span>( i = ROWS-1; i; --i )
        strcpy( text[ i ], text[ i-1 ] );
    cursor = 0;
    text[ 0 ][ 0 ] = <span class="charliteral">'\n'</span>;
    text[ 0 ][ 1 ] = 0;
}
<span class="keywordtype">void</span> hscroll( <span class="keywordtype">void</span> )
{
    <span class="keywordtype">int</span> i = 0;
    <span class="keywordflow">if</span>( text[ 0 ][ 0 ] )
        <span class="keywordflow">for</span>( i = 0; i &lt; COLS; ++i )
            text[ 0 ][ i ] = text[ 0 ][ i+1 ];
    text[ 0 ][ COLS ] = 0;
    --cursor;
    text[ 0 ][ cursor ] = <span class="charliteral">'\n'</span>;
}
<span class="keywordtype">void</span> add_char( <span class="keywordtype">char</span> c )
{
    text[ 0 ][ cursor++ ] = c;
    text[ 0 ][ cursor   ] = <span class="charliteral">'\n'</span>;
    text[ 0 ][ cursor+1 ] = 0;
    <span class="keywordflow">if</span>( COLS &lt;= cursor )
        hscroll( );
}



<span class="keywordtype">void</span> cb_onscreen_keyboard( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )
{
    <span class="keywordtype">int</span> texture_updated = 1;

    <span class="keywordflow">switch</span>( key )
    {
    <span class="keywordflow">case</span> <span class="charliteral">'\n'</span>:
    <span class="keywordflow">case</span> <span class="charliteral">'\r'</span>:
        vscroll( );
    <span class="keywordflow">case</span> <span class="charliteral">'R'</span> - <span class="charliteral">'@'</span>: <span class="comment">/* ^R */</span>
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <span class="charliteral">'S'</span> - <span class="charliteral">'@'</span>: <span class="comment">/* ^S */</span>
        save_window( save_file_name );
        texture_updated = 0;
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> '\x08': <span class="comment">/* backspace */</span>
        <span class="keywordflow">if</span>( cursor )
        {
            --cursor;
            text[ 0 ][ cursor+1 ] = 0;
            text[ 0 ][ cursor   ] = <span class="charliteral">'\n'</span>;
        }
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> '\x1b':
            exit( 0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">default</span>:
        add_char( key );
        <span class="keywordflow">break</span>;
    }
    <a class="code" href="group__window.html#ga12">glutSetWindow</a>( offscreen_id );
    <a class="code" href="group__window.html#ga2">glutPostRedisplay</a>( );
}


<span class="keywordtype">void</span> cb_onscreen_reshape( <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h)
{
    <span class="keywordtype">double</span> ar = w * 1.0/h;
    glEnable( GL_CULL_FACE );
    glCullFace( GL_BACK );
    glViewport( 0, 0, w, h );
    glMatrixMode( GL_PROJECTION );
    glLoadIdentity( );
    <span class="keywordflow">if</span>( ar &gt; 1 )
        glFrustum( -ar, ar, -1, 1, 2, 30 );
    <span class="keywordflow">else</span>
        glFrustum( -1, 1, -1/ar, 1/ar, 2, 30 );
    glMatrixMode( GL_MODELVIEW );
    glLoadIdentity( );
    glTranslated( 0, 0, -5 );
}
<span class="keywordtype">void</span> cb_offscreen_reshape( <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h)
{
    <span class="keyword">static</span> GLfloat light_1_loc[ 3 ] = { 3, 4, 5 };
    <span class="keyword">static</span> GLfloat light_1_col[ 3 ] = { 1, 1, 1 };
    <span class="keyword">static</span> GLfloat material_diff[ 3 ] = { 1, 0, 0 };
    <span class="keyword">static</span> GLfloat material_spec[ 3 ] = { 1, 1, 1 };
    <span class="keywordtype">double</span> ar = w * 1.0/h;

    glEnable( GL_CULL_FACE );
    glViewport( 0, 0, w, h );
    glMatrixMode( GL_PROJECTION );
    glLoadIdentity( );
    <span class="keywordflow">if</span>( ar &gt; 1 )
        glFrustum( -ar, ar, -1, 1, 2, 30 );
    <span class="keywordflow">else</span>
        glFrustum( -1, 1, -1/ar, 1/ar, 2, 30 );
    glTranslated( 0, 0, -3 );
    glMatrixMode( GL_MODELVIEW );
    glLoadIdentity( );
    glEnable( GL_LIGHT1 );
    glEnable( GL_LIGHTING );
    glLightfv( GL_LIGHT1, GL_POSITION, light_1_loc );
    glLightfv( GL_LIGHT1, GL_DIFFUSE, light_1_col );
    glLightfv( GL_LIGHT1, GL_SPECULAR, light_1_col );
    glMaterialfv( GL_FRONT_AND_BACK, GL_DIFFUSE, material_diff );
    glMaterialfv( GL_FRONT_AND_BACK, GL_SPECULAR, material_spec );
    glMaterialf( GL_FRONT_AND_BACK, GL_SHININESS, 90 );
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv )
{
    <a class="code" href="group__mainloop.html#ga0">glutInit</a>( &amp;argc, argv );
    <span class="keywordflow">if</span>( argv[ 1 ] )
        save_file_name = argv[ 1 ];

    strcpy( text[ 4 ], <span class="stringliteral">"Touch type,\n"</span> );
    strcpy( text[ 3 ], <span class="stringliteral">"on the\n"</span> );
    strcpy( text[ 2 ], <span class="stringliteral">"teapot\n"</span> );
    strcpy( text[ 1 ], <span class="stringliteral">"with me.\n"</span> );
    strcpy( text[ 0 ], <span class="stringliteral">"\n"</span> );
    <a class="code" href="group__window.html#ga7">glutInitDisplayMode</a>( GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE );
    onscreen_id = <a class="code" href="group__window.html#ga9">glutCreateWindow</a>( <span class="stringliteral">"Offscreen demo"</span> );
    <a class="code" href="group__windowcallback.html#ga0">glutDisplayFunc</a>( cb_onscreen_display );
    <a class="code" href="group__input.html#ga0">glutKeyboardFunc</a>( cb_onscreen_keyboard );
    <a class="code" href="group__windowcallback.html#ga1">glutReshapeFunc</a>( cb_onscreen_reshape );

    <a class="code" href="group__window.html#ga7">glutInitDisplayMode</a>(
        GLUT_RGB | GLUT_SINGLE | GLUT_DEPTH | GLUT_OFFSCREEN
    );
    <a class="code" href="group__window.html#ga6">glutInitWindowSize</a>( OFFSCREEN_W, OFFSCREEN_H );
    offscreen_id = <a class="code" href="group__window.html#ga9">glutCreateWindow</a>( <span class="stringliteral">""</span> );
    <a class="code" href="group__windowcallback.html#ga0">glutDisplayFunc</a>( cb_offscreen_display );
    cb_offscreen_reshape(  OFFSCREEN_W, OFFSCREEN_H );

    glGenTextures( 1, &amp;texName );
    glBindTexture( GL_TEXTURE_2D, texName );

    <a class="code" href="group__idletimer.html#ga0">glutIdleFunc</a>( cb_idle );

    <a class="code" href="group__mainloop.html#ga2">glutMainLoop</a>( );
    <span class="keywordflow">return</span> EXIT_SUCCESS;
}
</pre></div><br/><br/><br/><br/>
<div class="qindex">
<center><b>OpenGLUT Development @ Sourceforge</b></center>
<a class="qindex" href="http://openglut.sourceforge.net">Homepage</a> | 
<a class="qindex" href="http://sourceforge.net/projects/openglut/">Summary</a> | 
<a class="qindex" href="http://sourceforge.net/project/showfiles.php?group_id=104013">Files</a> | 
<a class="qindex" href="http://cvs.sourceforge.net/viewcvs.py/openglut">CVS</a> | 
<a class="qindex" href="http://sourceforge.net/forum/?group_id=104013">Forums</a> | 
<a class="qindex" href="http://sourceforge.net/mail/?group_id=104013">Lists</a> | 
<a class="qindex" href="http://sourceforge.net/tracker/?group_id=104013&atid=636633">Bugs</a> |
<a class="qindex" href="http://sourceforge.net/tracker/?group_id=104013&atid=636636">RFE</a>
</div>
<small>
<br/>
Generated on Tue Oct 5 18:44:24 2004 for OpenGLUT by
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.8<br/>
The OpenGLUT project is hosted by <a href="http://sourceforge.net">sourceforge.net</a>.
</small>
</body></html>
