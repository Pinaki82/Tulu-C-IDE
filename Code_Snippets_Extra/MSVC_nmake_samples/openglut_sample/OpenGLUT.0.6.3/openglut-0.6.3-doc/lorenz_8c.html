<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="KeyWords" content="OpenGLUT, FreeGLUT, OpenGL, GLUT, X11, Windows, Programming, Documentation, Download, Development, Sourceforge">
<title>OpenGLUT 0.6.3 development - OpenGLUT: lorenz.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<div class="qindex">
<center><b>OpenGLUT Documentation</b></center>
<a class="qindex" style="font-size: 80%" href="index.html">Introduction</a>         | 
<a class="qindex" style="font-size: 80%" href="group__api.html">Documentation</a>   | 
<a class="qindex" style="font-size: 80%" href="group__examples.html">Examples</a>   |  
<a class="qindex" style="font-size: 80%" href="group__proposals.html">Proposals</a> |
<a class="qindex" style="font-size: 80%" href="authors.html">Authors</a>            | 
<a class="qindex" style="font-size: 80%" href="copying.html">Copying</a>            | 
<a class="qindex" style="font-size: 80%" href="todo.html">Todo</a>                  | 
<a class="qindex" style="font-size: 80%" href="bug.html">Bugs</a>                   | 
<a class="qindex" style="font-size: 80%" href="otherdoc.html">Links</a> 
</div>
<!-- Generated by Doxygen 1.3.8 -->
<h1>lorenz.c File Reference</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Lorenz Strange Attractor<p>
What it does:<p>
This program starts with two particles right next to each other.<p>
The particles move through a three-dimensional phase space governed by the following equations:<p>
<ul>
<li><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {d \over dt} x = \sigma( y - x ) \]" src="form_1.png">
<p>
</li><li><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {d \over dt} y = r x - y + x z \]" src="form_2.png">
<p>
</li><li><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {d \over dt} z = x y + b z \]" src="form_3.png">
<p>
</li></ul>
<p>
These are the Lorenz equations and define the "Lorenz Attractor." Any two particles arbitrarily close together will move apart as time increases, but their tracks are confined within a region of the space.<p>
Commands:<p>
<ul>
<li><code>Arrow keys </code>: Rotate the view</li><li><code>PgUp, PgDn </code>: Zoom in and out</li><li><code>Mouse click</code>: Pick point on a particle trajectory</li><li><code>'r'/'R' </code>: Reset the simulation</li><li><code>'m'/'M' </code>: Modify the Lorenz parameters (in the text window)</li><li><code>'s'/'S' </code>: Stop (the advancement in time)</li><li><code>'g'/'G' </code>: Go</li><li><code>&lt;spacebar&gt; </code>: Single-step</li><li><code>&lt;Escape&gt; </code>: Quit</li></ul>
<p>
<div align="center">
<img src="openglut_lorenz.png" alt="openglut_lorenz.png">
<p><strong>OpenGLUT Lorenz Attractor Demonstration</strong></p></div>
<p>
<dl compact><dt><b>Author:</b></dt><dd>Written by John F. Fay in July 2003<p>
Portions Copyright (C) 2004, the OpenGLUT project contributors. <br>
 OpenGLUT branched from freeglut in February, 2004.</dd></dl>
<div class="fragment"><pre>
<span class="preprocessor">#include &lt;GL/openglut.h&gt;</span>

<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;math.h&gt;</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="preprocessor">#ifdef MSC_VER</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;crtdbg.h&gt;</span>  <span class="comment">/* DUMP MEMORY LEAKS */</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">/******************* Defined Constants ***************************************/</span>
<span class="comment">/* Number of points to draw in the curves */</span>
<span class="preprocessor">#define NUM_POINTS    512</span>
<span class="preprocessor"></span>
<span class="comment">/* Angle to rotate when the user presses an arrow key */</span>
<span class="preprocessor">#define ROTATION_ANGLE  5.0</span>
<span class="preprocessor"></span>
<span class="comment">/* Amount to scale bu when the user presses PgUp or PgDn */</span>
<span class="preprocessor">#define SCALE_FACTOR     0.8</span>
<span class="preprocessor"></span>

<span class="comment">/******************** Global Variables ***************************************/</span>
<span class="comment">/* Lorenz Attractor variables */</span>
<span class="keywordtype">double</span> s0 = 10.0, r0 = 28.0, b0 = 8.0/3.0;   <span class="comment">/* Default Lorenz parameters */</span>
<span class="keywordtype">double</span> time_step = 0.03;                     <span class="comment">/* Time step in the simulation */</span>
<span class="keywordtype">double</span> sigma = 10.0, r = 28.0, b = 8.0/3.0;  <span class="comment">/* Lorenz attactor parameters */</span>
<span class="keywordtype">double</span> red_position[ NUM_POINTS ][ 3 ];      <span class="comment">/* Path of the red point */</span>
<span class="keywordtype">double</span> grn_position[ NUM_POINTS ][ 3 ];      <span class="comment">/* Path of the green point */</span>
<span class="keywordtype">int</span> array_index;                             <span class="comment">/* Latest point in *_position */</span>
<span class="keywordtype">double</span> distance = 0.0;                       <span class="comment">/* Distance between red/green */</span>

<span class="comment">/* GLUT variables */</span>
<span class="comment">/* double yaw = 0.0, pit = 0.0; */</span>            <span class="comment">/* Viewing rotation */</span>
<span class="comment">/* double scale = 1.0;          */</span>            <span class="comment">/* Scale factor */</span>
<span class="keywordtype">double</span> xcen = 0.0, ycen = 0.0, zcen = 0.0;   <span class="comment">/* Coords of the examined point */</span>

<span class="keywordtype">int</span> animate = 1;                             <span class="comment">/* 0:stop, 1:go, 2:single-step */</span>


<span class="comment">/************************ Functions ******************************************/</span>

<span class="comment">/* The Lorenz Attractor */</span>
<span class="keywordtype">void</span> calc_deriv( <span class="keywordtype">double</span> position[ 3 ], <span class="keywordtype">double</span> deriv[ 3 ] )
{
    <span class="comment">/* Calculate the Lorenz attractor derivatives */</span>
    deriv[0] = sigma * ( position[ 1 ] - position[ 0 ] );
    deriv[1] =( r + position[ 2 ] ) * position[ 0 ] - position[ 1 ];
    deriv[2] = -position[ 0 ] * position[ 1 ] - b * position[ 2 ];
}

<span class="keywordtype">void</span> advance_in_time(
    <span class="keywordtype">double</span> time_step, <span class="keywordtype">double</span> position[ 3 ], <span class="keywordtype">double</span> new_position[ 3 ]
)
{
    <span class="comment">/* Move a point along the Lorenz attractor */</span>
    <span class="keywordtype">double</span> deriv0[ 3 ], deriv1[ 3 ], deriv2[ 3 ], deriv3[ 3 ];
    <span class="keywordtype">int</span> i;
    <span class="comment">/* Save the present values */</span>
    memcpy( new_position, position, 3 * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span> ) );

    <span class="comment">/* First pass in a Fourth-Order Runge-Kutta integration method */</span>
    calc_deriv( position, deriv0 );
    <span class="keywordflow">for</span>( i = 0; i &lt; 3; i++ )
        new_position[ i ] = position[ i ] + 0.5 * time_step * deriv0[ i ];

    <span class="comment">/* Second pass */</span>
    calc_deriv( new_position, deriv1 );
    <span class="keywordflow">for</span>( i = 0; i &lt; 3; i++ )
        new_position[ i ] = position[ i ] + 0.5 * time_step * deriv1[ i ];

    <span class="comment">/* Third pass */</span>
    calc_deriv( position, deriv2 );
    <span class="keywordflow">for</span>( i = 0; i &lt; 3; i++ )
        new_position[ i ] = position[ i ] + time_step * deriv2[ i ];

    <span class="comment">/* Second pass */</span>
    calc_deriv( new_position, deriv3 );
    <span class="keywordflow">for</span>( i = 0; i &lt; 3; i++ )
        new_position[ i ] = position[ i ] + 0.1666666666666666667 * time_step *
            ( deriv0[ i ] + 2.0 *( deriv1[ i ] + deriv2[ i ] ) + deriv3[ i ] );
}

<span class="comment">/* GLUT callbacks */</span>

<span class="preprocessor">#define INPUT_LINE_LENGTH 80</span>
<span class="preprocessor"></span>
<span class="keywordtype">void</span> key_cb( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )
{
    <span class="keywordtype">int</span> i;
    <span class="keywordtype">char</span> inputline [ INPUT_LINE_LENGTH ];

    <span class="keywordflow">switch</span>( key )
    {
    <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:
    <span class="keywordflow">case</span> <span class="charliteral">'R'</span>:  <span class="comment">/* Reset the simulation */</span>
        <span class="comment">/* Reset the Lorenz parameters */</span>
        sigma = s0;
        b = b0;
        r = r0;
        <span class="comment">/* Set an initial position */</span>
        red_position[ 0 ][ 0 ] = rand( ) / ( <span class="keywordtype">double</span> )RAND_MAX;
        red_position[ 0 ][ 1 ] = rand( ) / ( <span class="keywordtype">double</span> )RAND_MAX;
        red_position[ 0 ][ 2 ] = rand( ) / ( <span class="keywordtype">double</span> )RAND_MAX;
        grn_position[ 0 ][ 0 ] = rand( ) / ( <span class="keywordtype">double</span> )RAND_MAX;
        grn_position[ 0 ][ 1 ] = rand( ) / ( <span class="keywordtype">double</span> )RAND_MAX;
        grn_position[ 0 ][ 2 ] = rand( ) / ( <span class="keywordtype">double</span> )RAND_MAX;
        array_index = 0;
        <span class="comment">/* Initialize the arrays */</span>
        <span class="keywordflow">for</span>( i = 1; i &lt; NUM_POINTS; i++ )
        {
            memcpy( red_position[ i ], red_position[ 0 ], 3*<span class="keyword">sizeof</span>( <span class="keywordtype">double</span> ) );
            memcpy( grn_position[ i ], grn_position[ 0 ], 3*<span class="keyword">sizeof</span>( <span class="keywordtype">double</span> ) );
        }

        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <span class="charliteral">'m'</span>:
    <span class="keywordflow">case</span> <span class="charliteral">'M'</span>:  <span class="comment">/* Modify the Lorenz parameters */</span>
        printf(
            <span class="stringliteral">"Please enter new value for &lt;sigma&gt; (default %f, currently %f): "</span>,
            s0, sigma
        );
        fgets( inputline, INPUT_LINE_LENGTH- 1 , stdin );
        sscanf( inputline, <span class="stringliteral">"%lf"</span>, &amp;sigma );

        printf(
            <span class="stringliteral">"Please enter new value for &lt;b&gt; (default %f, currently %f): "</span>,
            b0, b
        );
        fgets( inputline, INPUT_LINE_LENGTH - 1, stdin );
        sscanf( inputline, <span class="stringliteral">"%lf"</span>, &amp;b );

        printf(
            <span class="stringliteral">"Please enter new value for &lt;r&gt; (default %f, currently %f): "</span>,
            r0, r
        );
        fgets( inputline, INPUT_LINE_LENGTH - 1, stdin );
        sscanf( inputline, <span class="stringliteral">"%lf"</span>, &amp;r );

        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
    <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:  <span class="comment">/* Stop the animation */</span>
        animate = 0;
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <span class="charliteral">'g'</span>:
    <span class="keywordflow">case</span> <span class="charliteral">'G'</span>:  <span class="comment">/* Start the animation */</span>
        animate = 1;
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <span class="charliteral">' '</span>:  <span class="comment">/* Spacebar:  Single step */</span>
        animate = 2;
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> 27:  <span class="comment">/* Escape key */</span>
        <a class="code" href="group__mainloop.html#ga3">glutLeaveMainLoop</a>( );
        <span class="keywordflow">break</span>;
    }
}

<span class="keywordtype">void</span> special_cb( <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )
{
    <span class="keywordflow">switch</span>( key )
    {
    <span class="keywordflow">case</span> GLUT_KEY_UP:  <span class="comment">/* Rotate up a little */</span>
        glRotated( ROTATION_ANGLE, 0.0, 1.0, 0.0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_DOWN:  <span class="comment">/* Rotate down a little */</span>
        glRotated( -ROTATION_ANGLE, 0.0, 1.0, 0.0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_LEFT:  <span class="comment">/* Rotate left a little */</span>
        glRotated( ROTATION_ANGLE, 0.0, 0.0, 1.0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_RIGHT:  <span class="comment">/* Rotate right a little */</span>
        glRotated( -ROTATION_ANGLE, 0.0, 0.0, 1.0 );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_PAGE_UP:  <span class="comment">/* Zoom in a little */</span>
        glScaled( 1.0 / SCALE_FACTOR, 1.0 / SCALE_FACTOR, 1.0 / SCALE_FACTOR );
        <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> GLUT_KEY_PAGE_DOWN:  <span class="comment">/* Zoom out a little */</span>
        glScaled( SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR );
        <span class="keywordflow">break</span>;
    }

    <a class="code" href="group__window.html#ga2">glutPostRedisplay</a>( );
}

<span class="keywordtype">void</span> mouse_cb( <span class="keywordtype">int</span> button, <span class="keywordtype">int</span> updown, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )
{
    <span class="keywordtype">double</span> dist = 1.0e20;  <span class="comment">/* A very large number */</span>
    <span class="keywordflow">if</span>( updown == GLUT_DOWN )
        dist = 0.0;  <span class="comment">/* so we don't get "unused variable" compiler warning */</span>
        <span class="comment">/*</span>
<span class="comment">         * The idea here is that we pick the nearest point</span>
<span class="comment">         * to the mouse click position.  Unfortunately I don't have the time to</span>
<span class="comment">         * implement it at the moment.</span>
<span class="comment">         *</span>
<span class="comment">         * XXX So, is that the nearest of the points in the ``trail''?</span>
<span class="comment">         * YYY (Yes, it is, John says.)</span>
<span class="comment">         */</span>
}

<span class="keywordtype">void</span> draw_curve( <span class="keywordtype">int</span> index, <span class="keywordtype">double</span> position[ NUM_POINTS ][ 3 ] )
{
    <span class="keywordtype">int</span> i = index;

    glBegin( GL_LINE_STRIP );
    <span class="keywordflow">do</span>
    {
        i = ( i == NUM_POINTS - 1 ) ? 0 : i + 1;
        glVertex3dv( position[ i ] );
    }
    <span class="keywordflow">while</span>( i != index );

    glEnd( );
}

<span class="keywordtype">void</span> display_cb( <span class="keywordtype">void</span> )
{
    <span class="keywordtype">char</span> string [ 80 ];

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    glColor3d( 1.0, 1.0, 1.0 );  <span class="comment">/* White */</span>
    <span class="comment">/* Draw some axes */</span>
    glBegin( GL_LINES );
    glVertex3d( 0.0, 0.0, 0.0 );
    glVertex3d( 2.0, 0.0, 0.0 );
    glVertex3d( 0.0, 0.0, 0.0 );
    glVertex3d( 0.0, 1.0, 0.0 );
    glVertex3d( 0.0, 0.0, 0.0 );
    glVertex3d( 0.0, 0.0, 1.0 );
    glEnd( );

    glColor3d( 1.0, 0.0, 0.0 );  <span class="comment">/* Red */</span>
    draw_curve( array_index, red_position );

    glColor3d( 0.0, 1.0, 0.0 );  <span class="comment">/* Green */</span>
    draw_curve( array_index, grn_position );

    <span class="comment">/* Print the distance between the two points */</span>
    glColor3d( 1.0, 1.0, 1.0 );  <span class="comment">/* White */</span>
    sprintf( string, <span class="stringliteral">"Distance: %10.6f"</span>, distance );
    glRasterPos2i( 10, 10 );
    <a class="code" href="group__bitmapfont.html#ga1">glutBitmapString</a>( GLUT_BITMAP_HELVETICA_12, string );

    <a class="code" href="group__window.html#ga3">glutSwapBuffers</a>( );
}

<span class="keywordtype">void</span> reshape_cb( <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height )
{
    <span class="keywordtype">double</span> ar;
    glViewport( 0, 0, width, height );
    glMatrixMode( GL_PROJECTION );
    glLoadIdentity( );
    ar =  width * 1.0 / height;
    <span class="keywordflow">if</span>( ar &gt; 1.0 )
    glFrustum( -ar, ar, -1.0, 1.0, 10.0, 100.0 );
    <span class="keywordflow">else</span>
    glFrustum( -1.0, 1.0, -1/ar, 1/ar, 10.0, 100.0 );
    glMatrixMode( GL_MODELVIEW );
    xcen = 0.0;
    ycen = 0.0;
    zcen = 0.0;
    glTranslated( xcen, ycen, zcen - 50.0 );
}


<span class="keywordtype">void</span> timer_cb( <span class="keywordtype">int</span> value )
{
    <span class="comment">/* Function called at intervals to update the positions of the points */</span>
    <span class="keywordtype">double</span> deltax, deltay, deltaz;
    <span class="keywordtype">int</span> new_index = array_index + 1;

    <span class="comment">/* Set the next timed callback */</span>
    <a class="code" href="group__idletimer.html#ga1">glutTimerFunc</a>( 30, timer_cb, 0 );

    <span class="keywordflow">if</span>( animate &gt; 0 )
    {
        <span class="keywordflow">if</span>( new_index == NUM_POINTS )
            new_index = 0;
        advance_in_time(
            time_step, red_position[ array_index ], red_position[ new_index ]
        );
        advance_in_time(
            time_step, grn_position[ array_index ], grn_position[ new_index ]
        );
        array_index = new_index;

        deltax =
            red_position[ new_index ][ 0 ] - grn_position[ new_index ][ 0 ];
        deltay =
            red_position[ new_index ][ 1 ] - grn_position[ new_index ][ 1 ];
        deltaz =
            red_position[ new_index ][ 2 ] - grn_position[ new_index ][ 2 ];
        distance = sqrt( deltax * deltax + deltay * deltay + deltaz * deltaz );

        <span class="keywordflow">if</span>( animate == 2 )
            animate = 0;
    }

    <a class="code" href="group__window.html#ga2">glutPostRedisplay</a>( );
}



<span class="comment">/* The Main Program */</span>

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] )
{
    <span class="keywordtype">int</span> pargc = argc;

    <span class="comment">/* Initialize the random number generator */</span>
    srand(( <span class="keywordtype">int</span> )time( NULL ) );

    <span class="comment">/* Set up the OpenGL parameters */</span>
    glEnable( GL_DEPTH_TEST );
    glClearColor( 0.0, 0.0, 0.0, 0.0 );
    glClearDepth( 1.0 );

    <span class="comment">/* Initialize GLUT */</span>
    <a class="code" href="group__window.html#ga6">glutInitWindowSize</a>( 600, 600 );
    <a class="code" href="group__mainloop.html#ga0">glutInit</a>( &amp;pargc, argv );
    <a class="code" href="group__window.html#ga7">glutInitDisplayMode</a>( GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH );

    <span class="comment">/* Create the window */</span>
    <a class="code" href="group__window.html#ga9">glutCreateWindow</a>( <span class="stringliteral">"Lorenz Attractor"</span> );
    <a class="code" href="group__input.html#ga0">glutKeyboardFunc</a>( key_cb );
    <a class="code" href="group__input.html#ga5">glutMouseFunc</a>( mouse_cb );
    <a class="code" href="group__input.html#ga1">glutSpecialFunc</a>( special_cb );
    <a class="code" href="group__windowcallback.html#ga0">glutDisplayFunc</a>( display_cb );
    <a class="code" href="group__windowcallback.html#ga1">glutReshapeFunc</a>( reshape_cb );
    <a class="code" href="group__idletimer.html#ga1">glutTimerFunc</a>( 30, timer_cb, 0 );

    <span class="comment">/*</span>
<span class="comment">     *  Initialize the attractor:</span>
<span class="comment">     *  The easiest way is to call the keyboard callback with an</span>
<span class="comment">     *  argument of 'r' for Reset.</span>
<span class="comment">     */</span>
    key_cb( <span class="charliteral">'r'</span>, 0, 0 );

    <span class="comment">/* Enter the GLUT main loop */</span>
    <a class="code" href="group__mainloop.html#ga2">glutMainLoop</a>( );

<span class="preprocessor">#ifdef MSC_VER</span>
<span class="preprocessor"></span>    _CrtDumpMemoryLeaks( );  <span class="comment">/* DUMP MEMORY LEAK INFORMATION */</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="keywordflow">return</span> EXIT_SUCCESS;
}

</pre></div><br/><br/><br/><br/>
<div class="qindex">
<center><b>OpenGLUT Development @ Sourceforge</b></center>
<a class="qindex" href="http://openglut.sourceforge.net">Homepage</a> | 
<a class="qindex" href="http://sourceforge.net/projects/openglut/">Summary</a> | 
<a class="qindex" href="http://sourceforge.net/project/showfiles.php?group_id=104013">Files</a> | 
<a class="qindex" href="http://cvs.sourceforge.net/viewcvs.py/openglut">CVS</a> | 
<a class="qindex" href="http://sourceforge.net/forum/?group_id=104013">Forums</a> | 
<a class="qindex" href="http://sourceforge.net/mail/?group_id=104013">Lists</a> | 
<a class="qindex" href="http://sourceforge.net/tracker/?group_id=104013&atid=636633">Bugs</a> |
<a class="qindex" href="http://sourceforge.net/tracker/?group_id=104013&atid=636636">RFE</a>
</div>
<small>
<br/>
Generated on Tue Oct 5 18:44:23 2004 for OpenGLUT by
<a href="http://www.doxygen.org/index.html">doxygen</a> 1.3.8<br/>
The OpenGLUT project is hosted by <a href="http://sourceforge.net">sourceforge.net</a>.
</small>
</body></html>
